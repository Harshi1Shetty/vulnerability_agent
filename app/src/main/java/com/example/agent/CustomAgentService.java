package com.example.agent;

import android.app.Service;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.content.pm.ServiceInfo;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.IBinder;
import android.util.Log;

import java.io.File;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;

import org.json.JSONObject;

public class CustomAgentService extends Service {
    private static final String TAG = "CustomAgentService";
    private static final long REPORT_INTERVAL = 30000; // 6 seconds for testing, change to 3600000 for 1 hour
    private Timer timer;

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "Service created");
        startReporting();
    }

    private void startReporting() {
        timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                sendReport();
            }
        }, 0, REPORT_INTERVAL); // Initial delay, then period
    }


    private void sendReport() {
        new Thread(() -> {
            try {
                URL url = new URL("http://ur_url/api/report");           //your local web address of the laptop running the console
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestMethod("POST");
                conn.setDoOutput(true);
                conn.setRequestProperty("Content-Type", "application/json");

                String reportData = generateReportData();
                Log.d(TAG, "Sending report data: " + reportData); // Log report data
                OutputStream os = conn.getOutputStream();
                os.write(reportData.getBytes());
                os.flush();
                os.close();

                int responseCode = conn.getResponseCode();
                Log.d(TAG, "Response Code: " + responseCode);

                conn.disconnect();
            } catch (Exception e) {
                Log.e(TAG, "Error sending report", e);
            }
        }).start();
    }

    private String generateReportData() {
        Map<String, Object> report = new HashMap<>();
        report.put("packageInfo", getPackageInfo());
        report.put("activities", getActivitiesInfo());
        report.put("broadcastReceivers", getBroadcastReceiversInfo());
        report.put("services", getServicesInfo());
        report.put("worldReadableFiles", getWorldReadableFiles());
        report.put("worldWritableFiles", getWorldWritableFiles());
        report.put("contentProviders", getContentProviders());
        report.put("sqlInjectionTest", performSQLInjectionTest());
        report.put("directoryTraversalTest", testDirectoryTraversal());

        return new JSONObject(report).toString();
    }

    private String getPackageInfo() {
        try {
            PackageManager pm = getPackageManager();
            PackageInfo pi = pm.getPackageInfo(getPackageName(), 0);
            ApplicationInfo ai = pm.getApplicationInfo(getPackageName(), 0);
            return "Package name: " + pi.packageName + "\nVersion: " + pi.versionName + "\nApp name: " + pm.getApplicationLabel(ai);
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, "Error getting package info", e);
            return "Error getting package info";
        }
    }

    private String getActivitiesInfo() {
        StringBuilder activitiesInfo = new StringBuilder();
        try {
            PackageManager pm = getPackageManager();
            ActivityInfo[] activities = pm.getPackageInfo(getPackageName(), PackageManager.GET_ACTIVITIES).activities;
            for (ActivityInfo activity : activities) {
                activitiesInfo.append(activity.name).append("\n");
            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, "Error getting activities info", e);
            return "Error getting activities info";
        }
        return activitiesInfo.toString();
    }

    private String getBroadcastReceiversInfo() {
        StringBuilder receiversInfo = new StringBuilder();
        try {
            PackageManager pm = getPackageManager();
            ActivityInfo[] receivers = pm.getPackageInfo(getPackageName(), PackageManager.GET_RECEIVERS).receivers;
            for (ActivityInfo receiver : receivers) {
                receiversInfo.append(receiver.name).append("\n");
            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, "Error getting broadcast receivers info", e);
            return "Error getting broadcast receivers info";
        }
        return receiversInfo.toString();
    }

    private String getServicesInfo() {
        StringBuilder servicesInfo = new StringBuilder();
        try {
            PackageManager pm = getPackageManager();
            ServiceInfo[] services = pm.getPackageInfo(getPackageName(), PackageManager.GET_SERVICES).services;
            for (ServiceInfo service : services) {
                servicesInfo.append(service.name).append("\n");
            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, "Error getting services info", e);
            return "Error getting services info";
        }
        return servicesInfo.toString();
    }

    private String getWorldReadableFiles() {
        File appDir = new File("/data/data/" + getPackageName());
        return getFilesWithPermissions(appDir, "r--");
    }

    private String getWorldWritableFiles() {
        File appDir = new File("/data/data/" + getPackageName());
        return getFilesWithPermissions(appDir, "-w-");
    }

    private String getFilesWithPermissions(File dir, String permissions) {
        StringBuilder filesInfo = new StringBuilder();
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    filesInfo.append(getFilesWithPermissions(file, permissions));
                } else {
                    if (file.canRead() && permissions.equals("r--")) {
                        filesInfo.append(file.getAbsolutePath()).append("\n");
                    }
                    if (file.canWrite() && permissions.equals("-w-")) {
                        filesInfo.append(file.getAbsolutePath()).append("\n");
                    }
                }
            }
        }
        return filesInfo.toString();
    }

    private String getContentProviders() {
        StringBuilder providersInfo = new StringBuilder();
        try {
            PackageManager pm = getPackageManager();
            ProviderInfo[] providers = pm.getPackageInfo(getPackageName(), PackageManager.GET_PROVIDERS).providers;
            for (ProviderInfo provider : providers) {
                providersInfo.append(provider.name).append("\n");
            }
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, "Error getting content providers info", e);
            return "Error getting content providers info";
        }
        return providersInfo.toString();
    }

    private String performSQLInjectionTest() {
        StringBuilder injectionResults = new StringBuilder();
        // Implement the logic to test for SQL Injection
        return injectionResults.toString();
    }

    private String testDirectoryTraversal() {
        StringBuilder traversalResults = new StringBuilder();
        // Implement the logic to test for directory traversal vulnerability
        return traversalResults.toString();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.d(TAG, "Service started");
        return START_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (timer != null) {
            timer.cancel();
        }
        Log.d(TAG, "Service destroyed");
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}
